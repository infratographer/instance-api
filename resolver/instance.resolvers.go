package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"

	"github.com/nrfta/go-paging"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"go.infratographer.com/instance-api/graph"
	"go.infratographer.com/instance-api/internal/models"
)

// Instances is the resolver for the instances field.
func (r *locationResolver) Instances(ctx context.Context, obj *graph.Location, page *paging.PageArgs) (*graph.InstanceConnection, error) {
	return loadInstances(ctx, page, r.db, models.InstanceWhere.LocationID.EQ(obj.ID))
}

// Instances is the resolver for the instances field.
func (r *tenantResolver) Instances(ctx context.Context, obj *graph.Tenant, page *paging.PageArgs) (*graph.InstanceConnection, error) {
	return loadInstances(ctx, page, r.db, models.InstanceWhere.TenantID.EQ(obj.ID))
}

// Location returns graph.LocationResolver implementation.
func (r *Resolver) Location() graph.LocationResolver { return &locationResolver{r} }

// Tenant returns graph.TenantResolver implementation.
func (r *Resolver) Tenant() graph.TenantResolver { return &tenantResolver{r} }

type locationResolver struct{ *Resolver }
type tenantResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func loadInstances(ctx context.Context, page *paging.PageArgs, db boil.ContextExecutor, mods ...qm.QueryMod) (*graph.InstanceConnection, error) {
	totalCount, err := models.Instances(mods...).Count(ctx, db)
	if err != nil {
		return &graph.InstanceConnection{
			PageInfo: paging.NewEmptyPageInfo(),
		}, err
	}

	paginator := paging.NewOffsetPaginator(page, totalCount)
	mods = append(mods, paginator.QueryMods()...)

	records, err := models.Instances(mods...).All(ctx, db)
	if err != nil {
		return &graph.InstanceConnection{
			PageInfo: paging.NewEmptyPageInfo(),
		}, err
	}

	result := &graph.InstanceConnection{
		PageInfo: &paginator.PageInfo,
	}

	addInstanceSliceToConnection(result, records, paginator)

	return result, nil
}
func addInstanceSliceToConnection(connection *graph.InstanceConnection, instances models.InstanceSlice, paginator paging.OffsetPaginator) {
	for i, row := range instances {

		res := &graph.Instance{
			ID:       row.ID,
			Name:     row.Name,
			Location: &graph.Location{ID: row.LocationID},
			Tenant:   &graph.Tenant{ID: row.TenantID},
			Provider: &graph.InstanceProvider{ID: row.InstanceProviderID},
		}

		connection.Edges = append(connection.Edges, &graph.InstanceEdge{
			Cursor: paging.EncodeOffsetCursor(paginator.Offset + i + 1),
			Node:   res,
		})

		connection.Nodes = append(connection.Nodes, res)
	}
}
